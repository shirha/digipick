<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  <!--link rel="manifest" href="manifest.json"-->
  <link rel="shortcut icon" type="image/png" href="favicon-512.png">
  <title>Starfield Digipick Solver</title>
<style>
  @font-face {
    font-family: "Lora"; 
    src: url("Lora-Regular.ttf");}
  body::-webkit-scrollbar {display: none;}
  body {overflow-y: scroll; margin: 0}
/*  input[type="file"]::file-selector-button {border-radius: 4px; border-width: 1px;}*/
  * {font-family: Lora; font-size: 18px; color: yellow;}
  #container {position: relative;}
  #menu {position: absolute; top: 50px; left: 50px; padding: 10px;}
  .black-text { color: black; }
  .yellow-text { color: yellow; }
  br:before { content: "\A"; white-space: pre-line }
</style>
</head>
<body onload="setTimeout( () => { window.scrollTo(0, 0) }, 100)">
  <div id="container">
    <div id="menu">
      <input type="file" id="imageInput" class="black-text" accept="image/*">
      <p id="sumResult"></p>
      <img id="warning" src="warning.jpg">
    </div>
    <canvas id="myCanvas" width="1920" height="1080"></canvas>
  </div>
<script>
const db = {};
const canvas = document.getElementById('myCanvas');
const context = canvas.getContext('2d');
const imageInput = document.getElementById('imageInput');
const sumResult = document.getElementById('sumResult');

// Add an event listener to the input element to load the image
// Function to load and draw an image onto the canvas
imageInput.addEventListener('change', function (event) {
  const file = event.target.files[0];
  if (file) {
    const reader = new FileReader();
    reader.onload = function(e) {
      const img = new Image();
      img.onload = function() {
        // Clear the canvas
        context.clearRect(0, 0, canvas.width, canvas.height);
        
        // Draw the image onto the canvas
        context.drawImage(img, 0, 0, canvas.width, canvas.height);

        // init
        sumResult.innerHTML  = '&nbsp;';
        imageInput.classList.add('yellow-text');
        document.getElementById('warning').style.display = 'none';
        drawCircles();

      };
      img.src = e.target.result;
    };
    reader.readAsDataURL(file);
  }
});

// Function to sum the values of a 7x7 square surrounding a point
function sumSurroundingSquare(context, x, y, size) {
  const imageData = context.getImageData(x - size / 2, y - size / 2, size, size);
  const data = imageData.data;
  let sum = 0;

  for (let i = 0; i < data.length; i += 4) {
    sum += data[i] + data[i+1] + data[i+2];
  }

  return sum;
}
const shiftKey = k => (k + 4) % 16;

function isIntersect(point, circle) {
  return Math.sqrt((point.x-circle.x) ** 2 + (point.y - circle.y) ** 2) < circle.radius;
}

// canvas2.addEventListener('click', (e) => {
//   const pos = {
//     x: e.clientX,
//     y: e.clientY
//   };
//   circles.forEach(circle => {
//     if (isIntersect(mousePoint, circle)) {
//       alert('click on circle: ' + circle.id);
//     }
//   });
// });

// Example usage: Sum the values of a 7x7 square centered at (100, 100)
canvas.addEventListener('click', function(event) {
  const x = event.offsetX;
  const y = event.offsetY;
  const size = 7;
  const sum = sumSurroundingSquare(context, x, y, size);
  // sumResult.textContent = `Sum of the 7x7 square: ${sum}`; // ${sum[0]}
});

function ptsBox(x, y, offset) {
  const points = [];

  for (let row = 0; row < 3; row++) {
    for (let col = 0; col < 4; col++) {
      const pointX = x + col * (offset+1);
      const pointY = y + row * (offset-2);
      points.push({ x: pointX, y: pointY });
    }
  }

  return points;
}

function levelCheck (context){
  let imageData, data, lockLevel = 0;
  // get advanced lock level data
  imageData = context.getImageData(1559, 259, 1, 21);
  data = imageData.data;
  let advanced = 0;
  for (let i = 0; i < data.length; i += 4) {
    advanced += data[i]; // red
  }

  // get expert lock level data
  imageData = context.getImageData(1555, 259, 1, 21); // todo
  data = imageData.data;
  let expert = 0;
  for (let i = 0; i < data.length; i += 4) {
    expert += data[i]; // red
  }

  // get master lock level data
  imageData = context.getImageData(1555, 259, 1, 21); // todo
  data = imageData.data;
  let master = 0;
  for (let i = 0; i < data.length; i += 4) {
    master += data[i]; // red
  }

  if(advanced / 21 > 200) {
    lockLevel = 1;
  } else if(expert / 21 > 200) {
    lockLevel = 2;
  } else if(master / 21 > 200) {
    lockLevel = 3;
  }

  return lockLevel;
}

function analyze(x, y, r, context, db, pick, fn) {
  const results = {key:[], sum:[]};

  if('flag' in db[pick]){
  // Insert the index of the lockRing
    context.font = '16px Arial';
    context.textAlign= 'center';
    context.textBaseline = 'middle';
    context.fillStyle = "yellow";
    if('lock' in db[pick]){
      context.fillText(db[pick].lock, x, y);
    }

    context.beginPath();
    context.arc(x, y, r, 0, 2 * Math.PI);
    context.strokeStyle = "yellow";
    context.stroke();
  }

  for (let i = 0; i < 16; i++) {
    const angle = (i * (360 / 16)) * (Math.PI / 180); // Calculate angle in radians
    const cx = x + r * Math.cos(angle); // X-coordinate of the circle center
    const cy = y + r * Math.sin(angle); // Y-coordinate of the circle center

    // Draw a circle
    if('key' in db[pick] && db[pick]['key'].includes(i)){
      context.beginPath();
      context.arc(cx, cy, 7, 0, Math.PI * 2);
      if('flag' in db[pick]){
        context.fillStyle = "black";
        context.fill();
      }
      context.strokeStyle = "yellow";
      context.stroke();
    }

    // Calculate the sum in the 7x7 square at the center of the circle
    results.sum.push( sumSurroundingSquare(context, cx, cy, 7) );
    if( fn(results.sum[i]) ) results.key.push( i );
  }

  return results;
}

let totalPct;
function analyze2(x, y, r, context) {
  const results = {key:[], pct:[]}, sample = [];

  for (let i = 0; i < 32; i++) {
    const angle = (i * (360 / 32)) * (Math.PI / 180); // Calculate angle in radians
    const cx = x + r * Math.cos(angle); // X-coordinate of the circle center
    const cy = y + r * Math.sin(angle); // Y-coordinate of the circle center

    // Calculate the sum in the 7x7 square at the center of the circle
    sample.push( sumSurroundingSquare(context, cx, cy, 7) );
  }

  for (let i = 0; i < 32; i+=2) {
    // Calculate the index of the previous and next major samples with wrap-around
    const prevIndex = (i + 31) % 32;
    const nextIndex = (i + 1) % 32;

    // Calculate the delta between the major sample and the average of its neighbors
    const avg = (sample[prevIndex] + sample[nextIndex]) / 2;
    const pct = parseInt(100 * sample[i] / avg);
    totalPct.push(pct);

    results.pct.push(pct);
    if(pct < 75) results.key.push(i / 2);
  }
  console.log(results);
  return results;
}

let lockRings, pickRings, solution;
function drawCircles() {
  lockRings = [], pickRings = [], solution = [];
  const radius = 40,
    solutionX = 148,
    centerX = 1405,
    // centerY = 511,
    offset = 112,
    lockX = 960,
    lockY = 541,
    lockRadius = [205, 168, 135, 105],
    lockSums = [...new Array(4)].map(() => []),
    pickSums = [...new Array(12)].map(() => []); 

  // db.level = levelCheck(context);
  const digiPickX = 1368;
  db.level = [458, 407, 357].map((y, i) => [accumDigipickStems(context, digiPickX, y), i])
    .sort((a, b) => b[0]-a[0])[0][1];
  const centerY = 461 + [100, 50, 0][db.level];

  // lockRadius.forEach((radius, pick) => lockSums[pick] = 
  //   analyze(lockX, lockY, radius, context, lockSums, pick, sum => sum < 4000));
  totalPct = [];
  lockRadius.forEach((radius, index) => lockSums[index] = 
    analyze2(lockX, lockY, radius, context));

  // const gap = findLargestDifference(totalPct.sort((a, b) => a-b));
  // sumResult.innerHTML = `level: ${['Novice','Advanced','Expert','Master'][db.level]}<br>gap: ${gap}`;
  // sumResult.innerHTML += '<br>'+
  //   `cir: ${sumRedOnCircumference(context,lockX,lockY,256)} ,`+
  //        `${sumRedOnCircumference(context,lockX,lockY,280)} ,`+
  //   `novice  : ${accumDigipickStems(context, 1368, 458)} ,`+
  //   `advanced: ${accumDigipickStems(context, 1368, 407)} ,`+
  //   `master  : ${accumDigipickStems(context, 1368, 357)}`

  console.log(JSON.stringify(lockSums, null, 2));
  console.log('\nlockSums:');
  for(let i = 0; i < lockSums.length; i++){
    console.log(`  [${i}]\{key:${JSON.stringify(lockSums[i].key)},`);
    console.log(`      sum:${JSON.stringify(lockSums[i].sum)}\}`);
  }
  lockRadius.forEach((radius, index) => 
    analyze(lockX, lockY, radius, context, lockSums, index, sum => 0));

  let pts = ptsBox(centerX, centerY, offset);
  pts.forEach((pt, index) => pickSums[index] = 
    analyze(pt.x, pt.y, radius, context, pickSums, index, sum => sum > 12000));
  // console.log(JSON.stringify(pickSums, null, 2));
  console.log('\npickSums:');
  // for(let i = 0; i < pickSums.length; i++){
  //   console.log(`  [${i}]\{key:${JSON.stringify(pickSums[i].key)},`);
  //   console.log(`      sum:${JSON.stringify(pickSums[i].sum)}\}`);
  // }

  pts.forEach((pt, index) => 
    analyze(pt.x, pt.y, radius, context, pickSums, index, sum => 0));

  pickSums.forEach(ring => pickRings.push(ring.key));
  while(pickRings[pickRings.length - 1].length === 0) pickRings.pop();

  lockSums.forEach(ring => lockRings.push(ring.key));
  lockRings.length = {4:2, 6:2, 9:3, 12:4}[pickRings.length];

  console.log('\npick=',JSON.stringify(pickRings));
  console.log('lock=',JSON.stringify(lockRings));

  try {
    solveLock(0, 0);
  } catch(err){
    console.log(err);
  }

  console.log('\nsolution:');
  for(let i = 0; i < solution.length; i++){
    console.log(' ',JSON.stringify(solution[i]));
  }

  let digiPicks = [...new Array(pickRings.length)].map((e) => e = {flag:0});
  solution.forEach(e => {
    digiPicks[e.pick].lock = e.lock;
    digiPicks[e.pick].key  = e.key;
  });
  console.log('\ndigiPicks:');
  for(let i = 0; i < digiPicks.length; i++){
    console.log(' ',JSON.stringify(digiPicks[i]));
  }

  let result = [];
  digiPicks.forEach((pick,i) => {
    if('key' in pick) {
      result.push(pick.lock, pick.key.map(k => (k + 4) % 16).sort((a, b) => a-b));
    }else{
      result.push('ø');
    }
  });
  sumResult.innerHTML += `<br>lock,[pins]: ${JSON.stringify(result).replace(/"/g,'')}`;

  pts = ptsBox(solutionX, centerY, offset);
  pts.length = pickRings.length;
  pts.forEach((pt, pick) => 
    analyze(pt.x, pt.y, radius, context, digiPicks, pick, sum => 0));
}

function solveLock(pickIndex, rotateIndex) {
  const currentPickRing = pickRings[pickIndex];

  for (let i = 0; i < lockRings.length; i++) {
    const currentLockRing = lockRings[i];
    const rotatePickRing  = currentPickRing.map(key => (key + rotateIndex) % 16);
    // console.log(`lock= ${i}, pick= ${pickIndex}, rotate= ${rotateIndex} [${rotatePickRing}]`);

    if(rotatePickRing.every(key => currentLockRing.includes(key))){
      lockRings[i] = currentLockRing.filter(key => !rotatePickRing.includes(key));

      console.log(` Used pick ${pickIndex} rotate ${rotateIndex} to unlock ring ${i} with keys ${rotatePickRing} lock ${JSON.stringify(lockRings)}`);
      solution.push({lock:i, pick:pickIndex, key:rotatePickRing});

      if(lockRings.every(ring => ring.length === 0)){
        throw "Lock open!";
      }

      if(pickIndex + 1 < pickRings.length){
        solveLock(pickIndex + 1, 0);  //<---
      }

      // Undo the pick to try other combinations
      lockRings[i] = lockRings[i].concat(rotatePickRing);

      console.log(`*Undo pick ${pickIndex} rotate ${rotateIndex} to unlock ring ${i} with keys ${rotatePickRing} lock ${JSON.stringify(lockRings)}`);
      solution.pop();
    }
  }

  if(rotateIndex + 1 < 16){
    solveLock(pickIndex, rotateIndex + 1);
  }else{
    if(pickIndex + 1 < pickRings.length){
      solveLock(pickIndex + 1, 0);
    }
  }
}

function findLargestDifference(numbers) {
  if (numbers.length < 2) {
    // Handle the case where there are not enough numbers.
    return null;
  }

  let largestDifference = -Infinity;
  let result = [];

  for (let i = 0; i < numbers.length - 1; i++) {
    const currNum = numbers[i];
    const nextNum = numbers[i + 1];
    const difference = nextNum - currNum;

    if (difference > largestDifference) {
      largestDifference = difference;
      result = [currNum, nextNum];
    }
  }

  return result;
}

function accumDigipickStems(context, x, y){ //console.log(x, y);
  context.fillStyle = "rgba(255,0,0,1)"; // alphaNormalized
  const stem = [1,19,44,52,69,93]; // DIIPIK
  let sum = [0, 0, 0];
  for(let s = 0; s < stem.length; s++){
    const imageData = context.getImageData(x + stem[s], y + 1, 1, 18);
    const data = imageData.data;
    // console.log(data);
    for (let i = 0; i < data.length; i+=4) { 
      sum[0] += data[i];
      sum[1] += data[i+1];
      sum[2] += data[i+2];
    }
    // context.fillRect(x + stem[s], y + 1, 1, 18);
  }

  return sum[0]+sum[1]+sum[2];
}

function sumRedOnCircumference(context, x, y, radius) {
  context.fillStyle = "rgba(255,0,0,1)"; // alphaNormalized
  let redSum = 0;

  for (let angle = 0; angle < 360; angle++) {
    const radians = (angle * Math.PI) / 180;
    const px = x + radius * Math.cos(radians);
    const py = y + radius * Math.sin(radians);

    const pixel = context.getImageData(px, py, 1, 1).data;
    redSum += pixel[0]; // Red component (R) at index 0
    // context.fillRect(px, py, 1, 1);
  }

  return redSum;
}
</script>
</body>
</html>
